:PROPERTIES:
:ID: 2d5fffc1-20cd-45f8-994b-638481352951
:ROAM_ORIGIN: 4c2571b3-e416-48c0-bf7d-4d93af0ce820
:END:
#+TITLE: A Guide to Git

#+OPTIONS: title:nil tags:nil todo:nil ^:nil f:t num:t pri:nil toc:t
#+LATEX_HEADER: \renewcommand\maketitle{} \usepackage[scaled]{helvet} \renewcommand\familydefault{\sfdefault}
#+TODO: TODO(t) (e) DOIN(d) PEND(p) OUTL(o) EXPL(x) FDBK(b) WAIT(w) NEXT(n) IDEA(i) | ABRT(a) PRTL(r) RVIW(v) DONE(f)
#+FILETAGS: :DOC:PROJECT:PACKAGES:GIT:
#+HTML:<details>

* A Guide to Git :DOC:META:PACKAGES:GIT:
#+HTML:</details>
- *OBJECTIVE:* /Improve workflow with nvim, fugitive, lazygit/
- *References:*
  - [[https://youtu.be/vtFXMni91Q4#__preview][Fugitive workflow @Youtube-preview]]
  - [[https://www.youtube.com/watch?v=G3NJzFX6XhY#__preview][Config your git @Youtube]]
** Git Operations
/Understand the fundamentals of the git tool/
*** Git config
There are two locations a git config file can exist:
- *Local* git repo: in the repo itself (and ignored by ~.gitignore~)
- *Global* exist outside of the repo e.g. [[file:/home/whammou/.gitconfig][gitconfig]]
*** Git merge vs re-base vs squashing :gitmerge:gitrebase:gtsquash:
There are different strategies to merge two ~branches~:
- *Merging -* Merge and ties together the ~history~ of both ~branches~
- *Re-basing -* Merge the ~commits~ of a branch to the *tip* of ~main~ and then performs a ~fast-forward-merge~
  + *Fast-forward -* =merge= and move the pointer of the target branch forward to the latest commit of the course branch /avoiding the need to create a merge commit/
- *Squashing -* Squeeze all the ~commits~ of ~feature branch~ into one single ~commit~ and merge it with ~main~
*** Git commit vs stash :gitcommit:gitstash:
Visit:* [[https://paulapivat.com/technical_notes/example_tech/git_stash/][Git Stash vs Git Commit]]
** Write better commit messages
- *Goal(s):* Write better and more comprehensive commit messages
- *Stumble upon:* [[https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages/]]
*** The Anatomy of a Commit Message
- *Basic:*
  =git commit -m <message>=
- *Detailed:*
  =git commit -m <title> -m <description>=
*** 5 Steps to write a better commit message
- Note taken on [2024-09-21 Sat 21:37] \\
  To come up with thoughtful commits consider the following: 
  - Why have I made these changes?
  - What effect have my changes made?
  - Why was the change needed?
  - What are the changes in reference?
    
1. *Capitalization and Punctuation:*
   Capitalize the first word and do not end in punctuation. If using /Convention Commits/, remember to use all lowercase
2. *Mood:*
   Use imperative mood in the subject line. *Example -* =Add fix= for =dark mode toggle state=. Imperative mood fives the tone you are giving in /order/ or /request/
3. *Type of Commit:*
   Specify the type of commit. It is recommended and can be even more beneficial to have consistent set of words to describe your changes. *Example:* /Bugfix/, /Update/, /Retractor/, /Bump/, and so on.
4. *Length:*
   The first line should ideally be no longer than 50 chars, and the body should be restricted to 72 chars
5. *Content:*
   Be direct, try to eliminate fillers words and phrases in theses sentences (*Example:* though, maybe, I think, kind of), Think like a journalist
*** Conventional Commits
Conventional Commit is a formatting convention that provides as set of rules to formulate a consistent commit message structure like so:

#+NAME: Conventional Commit structure
#+BEGIN_SRC
<type>[option scope]: <description>

[optional body]

[optional footer(s)]
#+END_SRC

The commit =type= can include the following:

- =feat= -a new feature is introduces with the changes
- =fix= -a bug fix has occurred
- =chore= -changes that do not relate to a fix or feature and don't modify src or test files (for example updating dependencies)
- =refractor= -refactored code that neither fixes a bug nor adds a feature
- =doc= - updates to documentation such as the README or other markdown files
- =style= -changes that do not affect the meaning of the code, likely realted to code formatting such as white-space, missing semi-colons, and so on
- =test= -including new or correcting previous tests
- =perf= -performance improvements
- =ci= -continuous integration related
- =build= -changes tha affect the build system or external dependencies
- =revert= -reverts a previous commit
  
/The commit type subject line should be all lowercase with a character limit to encourage succinct descriptions/

The =[optional commit body]= should be used to provide detail that cannot fit within the character limitations of the subject line description

It is also good location to utilize =BREAKING CHANGE: <description>= to note the reason for a breaking change within the commit

The =[footer]= is also optional. We use the footer to link the JIRA story what would be closed with these changes for example:
=Closes D2!I-<JIRA #>=

#+NAME: Full Conventional Commit Example
#+BEGIN_SRC
fix: fix foo to enable bar

This fixes the broken behavior of the component by doing xyz.

BREAKING CHANGE
Before this fix foo wasn't enabled at all, behavior changes from <old> to <new>

Closes D2IQ-12345
#+END_SRC

- *NOTE*
  The ensure that these committing conventions remain consistent across developers, commit message linting can be configured before changes are able to be pushed up. [[https://commitizen-tools.github.io/commitizen/][Commitizen]] is a great tool to enforce standards, sync up semantic versioning, along with other helpful features
** Clean commit history
- *OBJECTIVE:* Clean up git commit history
- *Reference:* [[https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History][Git tools rewrite history @Doc-git]]
** Securely storing secrets in git
- *OBJECTIVE:* Learn how to securely store secrets in git
** DONE Managing A Nested Git Project :GIT:MANAGEMENT:
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-06 Mon 17:42]
:PROPERTIES:
:ID: 0ac3ce98-9f59-468f-acfd-c494c879986b
:END:
For an open-source organization, it can be tricky to achieve single-source =documentation= and =dependency management= for the community and the product. The =documentation= and =project= often end up fragmented and redundant, which makes them difficult to maintain

#+html:<details>
#+html:<summary>git subtree</summary>
[[https://opensource.com/article/20/5/git-submodules-subtrees][https://opensource.com/sites/default/files/subtree_0.png]]
#+html:</details>
- *Reference:* [[https://ao.bloat.cat/exchange/stackoverflow.com/questions/35534766/how-to-create-submodule-in-existing-repo][How to create a nested project @Overflow]]
*** DONE Git Submodules Approach
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-06 Mon 17:42]
:PROPERTIES:
:ID: 35ff8cc5-522d-423e-b9e1-0d4e067e737b
:END:
- Git =submodules= are /git repositories/ within a /git repository/
  + The =submodule= are pointers which points to a *specific commit* of the /child repository/
  + =Submodule= can be /nested/ - meaning you can have a =submodule= of a =submodule=
- This approach meaning you can have a working tree of submodules as a working directory tree
  
#+NAME:Nested submodules pointers
#+BEGIN_QUOTE markdown
[!WARNING]
=submodules= are pointer to s specific commit meaning having too many layers of them can obstruct workflow as you will have to update each =submodule= along with its new pointers
#+END_QUOTE
**** DONE Clone and Load Submodules
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-06 Mon 17:50]
Downloading =submodules= sequentially can be a tedious task, so =clone= and =submodule update= will support the =--jobs= or =-j= parameter

#+NAME:Download submodules in parallel
#+BEGIN_SRC bash
git submodule update --init --recursive -j8
git clone --recursive --jobs 8 <URL to git repo>
#+END_SRC
**** DONE Add Submodules
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-06 Mon 17:58]
- To add a child repository to parent repository:
  #+BEGIN_SRC bash
  git submodule add <URL to Git repo>
  #+END_SRC
  + To create an empty repository on remote (using =github-cli=)
    #+BEGIN_SRC bash
    gh repo create <Repo name> --public
    #+END_SRC
- To Initialize an existing Git submodule
  #+BEGIN_SRC bash
  git submodule init
  #+END_SRC
**** DONE Remove a Submodule
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-06 Mon 23:13]
Merely deleting a child project manually won't remove the child project from the parent repository as it is staged. To delete a /child repository/ run:
#+BEGIN_SRC bash
git rm -rf submodule
#+END_SRC
**** DONE Pull submodules
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-06 Mon 23:06]
Before building or running the /parent repository/, you have to make sure that the child /dependencies/ are up to date
+ To pull all changes in submodules:
  #+BEGIN_SRC bash
    git submodule update --remote
  #+END_SRC
**** DONE Make Changes to Submodules
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-07 Tue 02:57]
:PROPERTIES:
:ID: 0d065ce6-e02a-4dce-b7a5-29a1910d0e9c
:END:
As mentioned above =submodules= are pointer to a specific =commit= of a /repository/. Thus in order to make changes in a =submodule= (from parent repository) you have to first checkout to an existing =branch= as opposed to a =commit=

#+NAME:Running commnand from outside a git directory
#+BEGIN_QUOTE markdown
[!TIP]
=git= support running command from outside of the /working directory/ using command =git -C path/to/repo <command>=
#+END_QUOTE

+ To checkout a submodule:
  #+BEGIN_SRC bash
    git -C path/to/submodule checkout main # or any preferred branch
  #+END_SRC
+ Then edit on the =submodule= like a /standalone repository/
    * To commit changes
      #+BEGIN_SRC bash
      git -C path/to/submodule commit -m "<message>" <files>
      #+END_SRC
    * To push changes of a =child-repo= from the =parent-repo=
      #+BEGIN_SRC bash
      git -C /path/to/submodule push origin main # or any preferred branch
      #+END_SRC
    * To pull changes to =child-repo=, using the same command
      #+BEGIN_SRC bash
      git -C /path/to/submodule/ pull
      #+END_SRC

#+NAME:Run command in parallel
#+BEGIN_QUOTE markdown
[!NOTE]
Git support running command for each initialized /child repository/ using =git submodule foreach <command>=. However this run =commands= in sequence thus takes up a lot of time to finish all commands on every =submodules=. In stead running =commands= in parallel might take more overhead but less time
#+END_QUOTE
*** DONE Symlinks Approach
DEADLINE: <2025-10-06 Mon> CLOSED: [2025-10-06 Mon 23:35]
Managing a /nested project/ can be a tedious tasks. Especially when the =child-repo= contains different =child-repos=. This create a layer of index to different pointer to maintain when making changes to any =child-repo=. Thus instead of create a nested level, use =symlink= to create a list of local pointer the stay fixed even when a =child-repo= is changed
#+BEGIN_SRC bash
ln -s absolute/path/to/submodule -t target/dir
#+END_SRC
